/**
 * @ai Generated by ChatGPT
 * @date 2025-07-27
 */

import { IPoint, TXpertGraph, TXpertTeamConnection, TXpertTeamNode } from '@cloud/app/@core'
import ELK from 'elkjs'

const NODE_WIDTH = 240

const elk = new ELK()

export async function layoutGraphWithMixedDirection(graph: TXpertGraph) {
  const nodeMap = new Map(graph.nodes.map((n) => [n.key, n]))
  const connectionMap = new Map<string, TXpertTeamConnection[]>()

  for (const conn of graph.connections) {
    if (!connectionMap.has(conn.from)) connectionMap.set(conn.from, [])
    if (!connectionMap.has(conn.to)) connectionMap.set(conn.to, [])
    connectionMap.get(conn.from)!.push(conn)
    connectionMap.get(conn.to)!.push(conn)
  }

  const horizontalChain = extractHorizontalChain(graph)

  const visited = new Set<string>()
  const positionedNodes: Record<string, IPoint> = {}

  let offsetX = 0

  for (const nodeId of horizontalChain) {
    const subtree = await layoutVerticalSubtree(nodeId, nodeMap, connectionMap, visited)

    for (const n of subtree.nodes) {
      n.x = (n.x ?? 0) + offsetX
      n.y = n.y ?? 0
      positionedNodes[n.id] = { x: n.x, y: n.y }
    }

    offsetX += subtree.width + 80 // horizontal spacing
  }

  // Write back node positions
  for (const node of graph.nodes) {
    const pos = positionedNodes[node.key]
    if (pos) {
      node.position.x = pos.x
      node.position.y = pos.y
    }
  }

  return graph
}

// ========== STEP 1: Subtree Layout ==========
async function layoutVerticalSubtree(
  rootId: string,
  nodeMap: Map<string, TXpertTeamNode>,
  connectionMap: Map<string, TXpertTeamConnection[]>,
  visited: Set<string>
): Promise<{ nodes: any[]; width: number; height: number }> {
  const nodes: any[] = []
  const edges: any[] = []

  const queue = [rootId]
  visited.add(rootId)

  while (queue.length > 0) {
    const nodeId = queue.shift()!
    const node = nodeMap.get(nodeId)
    if (!node) continue

    const width = node.size?.width ?? NODE_WIDTH
    const height = node.size?.height ?? NODE_WIDTH
    nodes.push({ id: nodeId, width, height })

    const conns = connectionMap.get(nodeId) || []
    for (const conn of conns) {
      if (conn.type === 'edge') continue // Only process vertical connections
      const targetId = conn.from === nodeId ? conn.to : conn.from
      if (visited.has(targetId)) continue

      queue.push(targetId)
      visited.add(targetId)
      edges.push({
        id: conn.key,
        sources: [nodeId],
        targets: [targetId]
      })
    }
  }

  const elkGraph = {
    id: `subtree_${rootId}`,
    children: nodes,
    edges,
    layoutOptions: {
      'elk.algorithm': 'layered',
      'elk.direction': 'DOWN',
      'elk.spacing.nodeNode': '50'
    }
  }

  const layout = await elk.layout(elkGraph)
  return {
    nodes: layout.children,
    width: layout.width ?? 0,
    height: layout.height ?? 0
  }
}

// ========== STEP 2: Extract Horizontal Main Chain ==========
function extractHorizontalChain(graph: TXpertGraph): string[] {
  const edgeConns = graph.connections.filter((c) => c.type === 'edge')
  const allEdgeNodes = new Set(edgeConns.flatMap((c) => [c.from, c.to]))

  // Case 1: There are edge type connections, build the main chain
  if (edgeConns.length > 0) {
    const fromSet = new Set(edgeConns.map((c) => c.from))
    const toSet = new Set(edgeConns.map((c) => c.to))
    const startNode = [...fromSet].find((n) => !toSet.has(n)) || edgeConns[0].from

    const chain: string[] = [startNode]
    let current = startNode

    while (true) {
      const next = edgeConns.find((c) => c.from === current)?.to
      if (!next || chain.includes(next)) break
      chain.push(next)
      current = next
    }

    return chain
  }

  // Case 2: No edge connections, find all nodes with in-degree 0 as starting points
  const allNodes = graph.nodes.map((n) => n.key)
  const nonStartNodes = new Set(graph.connections.map((c) => c.to))
  const possibleStarts = allNodes.filter((n) => !nonStartNodes.has(n))

  if (possibleStarts.length > 0) {
    return possibleStarts // Each can be the only member of the "horizontal main chain"
  }

  // Case 3: All nodes have been referenced, fallback to the first node as the only chain
  return allNodes.length > 0 ? [allNodes[0]] : []
}
